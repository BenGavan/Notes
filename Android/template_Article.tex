\documentclass[]{article}

% imports
\usepackage{listings}
\usepackage{color}
\definecolor{lightgray}{rgb}{0.95, 0.95, 0.95}
\definecolor{darkgray}{rgb}{.4,.4,.4}
\definecolor{purple}{rgb}{0.65, 0.12, 0.82}

\lstdefinelanguage{JavaScript}{
	keywords={typeof, new, true, false, catch, function, return, null, catch, switch, var, if, in, while, do, else, case, break},
	keywordstyle=\color{blue}\bfseries,
	ndkeywords={class, export, boolean, throw, implements, import, this},
	ndkeywordstyle=\color{darkgray}\bfseries,
	identifierstyle=\color{black},
	sensitive=false,
	comment=[l]{//},
	morecomment=[s]{/*}{*/},
	commentstyle=\color{purple}\ttfamily,
	stringstyle=\color{red}\ttfamily,
	morestring=[b]',
	morestring=[b]"
}

\lstset{
	language=JavaScript,
	backgroundcolor=\color{lightgray},
	extendedchars=true,
	basicstyle=\footnotesize\ttfamily,
	showstringspaces=false,
	showspaces=false,
	numbers=left,
	numberstyle=\footnotesize,
	numbersep=9pt,
	tabsize=2,
	breaklines=true,
	showtabs=false,
	captionpos=b
}

%opening
\title{Android}
\author{Ben Gavan}

\begin{document}

\maketitle
\tableofcontents

%%%%%%%%%%%%%%%%%%%%% Dialogs %%%%%%%%%%%%%%%%%%%%%%
\section{Dialogs}
\subsection{Setting a Target Fragment}
When displaying a dialog view from a fragment, we need to create a relationship between them se we can send data back from the dialog to the fragment.  
\\
We need to pass a reference to the dialog of the fragment, as well as a request code to identify the payload when it is sent back/ so the fragment can 'listen' out for it.
\\
We do this by setting the target fragment on the dialog object:
\begin{lstlisting}
dialog.setTargetFragment(FragmentClass.this, REQUEST_CODE);
\end{lstlisting}

\subsection{Sending data back to the Target Fragment from the Dialog}
We should also check that the target fragment has been set before we do anything
\\
First, we need to get a reference to the target fragment (set by the fragment requesting the display of the dialog via using setTargetFragment on the dialog).
\\
We then call 'onActivityResult' on the target fragment.
\\
So if we want to do something in the fragment i.e. get the data back, we have to override this method in the target fragment.
\\
The data we pass back from the dialog is contained within an intent by putExtra.
\begin{lstlisting}
private void sendResult(int resultCode, Date date) {
	if (getTargetFragment() == null) {
		return;
	}

	Intent intent = new Intent();
	intent.putExtra(EXTRA_DATE, date);

	this.getTargetFragment().onActivityResult(this.getTargetRequestCode(), resultCode, intent);
}
\end{lstlisting}

\subsubsection{Receiving the Data from the intent}
\begin{lstlisting}
@Override
public void onActivityResult(int requestCode, int resultCode, Intent data) {
	if (resultCode != Activity.RESULT_OK) {
		return;
	}

	if (requestCode == REQUEST_DATE) {
		Date date = (Date) data.getSerializableExtra(DatePickerFragment.EXTRA_DATE);
		mCrime.setDate(date);
		mDateButton.setText(mCrime.getDate().toString());
	}
}
\end{lstlisting}
We override the 'onActivityResult' within the target fragment we are sending data back to.
\\
First we check what the result code is (what button the user pressed on the dialog)
\begin{lstlisting}
if (resultCode != Activity.RESULT_OK) {
	return;
}
\end{lstlisting}
We then check what the request code is (which was set by the fragment creating the dialog) so we know that we are responding to the correct result (A fragment can display and react to multiple dialogs). 
\\
After this, we get the data sent back in the form of an extra from the dialog inside an intent by 'getSerializableExtra(...)'.
\\
In this case, we cast this data back to a date so it can be used.
\begin{lstlisting}
if (requestCode == REQUEST_DATE) {
	Date date = (Date) data.getSerializableExtra(DatePickerFragment.EXTRA_DATE);
	mCrime.setDate(date);
	mDateButton.setText(mCrime.getDate().toString());
}
\end{lstlisting}

%%%%%%%%%%%%%%%%%%%%% Toolbar %%%%%%%%%%%%%%%%%%%%%%
\section{The Toolbar}
The Toolbar provides additional mechanisms for navigation, nd also provides design consistency and branding.
\subsubsection{History}
The toolbar component was added to android 5.0 (Lollipop).
\\
Prior to this, the action bar was the recommended component for navigation and actions within an app.
\\
The toolbar and action bar are very similar.
\\
The toolbar builds on top of the action bar .
\\
It has a tweaked UI
\\ 
It's more flexible in the ways you can use it.
\subsubsection{Supported by}
Since the toolbar has been added to the AppCompat library, it is available back to API 9 (Android 2.3)

\subsection{Menus}
The top-right portion of the toolbar is reserved for the toolbar's menu.
\\
The menu consists of action items (sometimes referred to as menu items).
\\
These can perform an action on the current screen or on the app as a whole.

\subsubsection{Defining a menu in XML}
Need to create an XML description of a menu, just like how you have to for layouts, with the resource file inside the res/menu directory.
\\
To create a new menu resource file:
\begin{enumerate}
	\item Right-click on the res directory
	\item Select New $\rightarrow$ Android resource file
	\item Change the Resource type to Menu 
	\item Name the resource (normally 'fragment\_...' - the same naming convention as layout files)
	\item Click OK
\end{enumerate}
In this file, the XML should be:
\begin{lstlisting}
<?xml version="1.0" encoding="utf-8"?>
<menu xmlns:android="http://schemas.android.com/apk/res/android"
			xmlns:app="http://schemas.android.com/apk/res-auto">
</menu>
\end{lstlisting}

\subsubsection{Defining an item}
\begin{lstlisting}
<item
	android:id="@+id/new_crime"
	android:icon="@android:drawable/ic_menu_add"
	android:title="@string/new_crime"
	app:showAsAction="ifRoom|withText"/>
\end{lstlisting}
The line 
\begin{lstlisting}
app:showAsAction="ifRoom|withText"
\end{lstlisting}
makes the item be displayed inline/on the toolbar (where the menu icon should be) instead of having the item as a drop down item below the toolbar/menu button.
\\
The showAsAction attribute refers to whether the item will appear in the toolbar itself or in the overflow menu.
\\\\
In this case "ifRoom$|$withText" will make the items icon and text appear in the toolbar if there is room.  
\\If there is room for the icon but not the text, then only the icon will be visible. 
\\If there is no room for either, the item will be relegated to the overflow menu.
\\\\
If there are items in the overflow menu, the three dots will appear and when these are pressed, the overflow menu will be shown below.
\\\\
Multiple menu items can be displayed as Actions on the Toolbar.
\\\\
\paragraph{Possible values for showAsAction}
\begin{itemize}
	\item always 
	\subitem not recommended 
	\subitem Better to use ifRoom and let the OS decide.
	
	\item ifRoom
	\subitem Only displays the item as an Action if there is room
	
	\item never
	\subitem never displayed as an action
	\subitem will always appear in the overflow menu
	\subitem so good for items that are not used very often - its good practice to avoid having to many items on the toolbar to help the screen keep decluttered 
\end{itemize}
The AppCompat library defines its own custom showAsAction attribute and does not look for the native showAsAction attribute.

\subsubsection{Creating the Menu}
Override the function onCreateOptionsMenu(...) inside the Activity/Fragment.
\\
To actually create/inflate the menu:  (Inside the Fragment:)
\begin{lstlisting}
@Override
public void onCreateOptionsMenu(Menu menu, MenuInflater inflater) {
	super.onCreateOptionsMenu(menu, inflater);
	inflater.inflate(R.menu.fragment_crime_list, menu);
}
\end{lstlisting}
This populates the menu with the items defined in the menu/fragment\_crime\_list.xml file.
\\
The super call is only convention since the superclass, Fragment, does nothing.  (Good to do so the superclass functionality is still applied - can now change the superclass and will still work if we do something in that implementation of this function).
\\\\
We then need to call setHasOptionsMenu(boolean hasMenu) to tell the FragmentManager that this fragment has a menu and should receive a call to onCreateOptionsMenu(...).
\\
Inside the Fragment:
\begin{lstlisting}
@Override
public void onCreate(@Nullable Bundle savedInstanceState) {
	super.onCreate(savedInstanceState);
	setHasOptionsMenu(true);
}
\end{lstlisting}

\subsubsection{Responding to Menu Selection}
Override onOptionsItemSected(...) in the fragment that you have called 'setHasOptionsMenu(true)'.
\\
The MenuItem.getItemId() corresponds to the id of the $<$item$>$ which you set in the xml file for the menu.
\\
This means that we can perform a switch case for each possible id in the menu.
\\
Include a default case to let the super implementation to handle the section of any item that you have not declared.
\\
You should return true you you have handled the item section and that no further processing is necessary.
\begin{lstlisting}
@Override
public boolean onOptionsItemSelected(MenuItem item) {
	switch (item.getItemId()) {
		case R.id.new_crime:
			.... Do some logic here ....
			return true;   // Return true to say that the selection has been handled.
		default:
			return super.onOptionsItemSelected(item);
	}
}
\end{lstlisting}

\subsubsection{Reload/update the menu}
\begin{lstlisting}
getActivity().invalidateOptionsMenu();
\end{lstlisting}
This will cause the menu to be redrawn/reloaded (just like if the device is rotated).
\subsection{Subtitle}
\begin{lstlisting}
private void setSubtitle(String subtitle) {
	AppCompatActivity activity = (AppCompatActivity) getActivity();
	activity.getSupportActionBar().setSubtitle(subtitle);
}
\end{lstlisting}
\begin{itemize}
	\item Get the current activity
	\subitem (We are using AppCompat for backwards compatibility)
	
	\item Get the Toolbar from that activity via getSupportActionBar()
	\subitem Still called/referred to as an Action Bar due to legacy reasons.
	
	\item Set the subtitle of that the toolbar we just received.
\end{itemize}

\subsection{Hierarchical Navigation}
Add parentActivityName to the activity the the manifests so when you press the back arrow on the toolbar, it will go back to the activity you stated.
\begin{lstlisting}
<activity
	android:name=".CrimePagerActivity"
	android:parentActivityName=".CrimeListActivity"/>
\end{lstlisting}

\subsubsection{How Hierarchical Navigation works}
Page 261

%%%%%%%%%%%%%%%%%%%%% AppCompat Library %%%%%%%%%%%%%%%%%%%%%%
\section{AppCompat Library}
\subsection{Requirements}
The AppCompat requires that you:
\begin{itemize}
	\item add the AppCompat dependency
	\item use one of the AppCompat themes 
	\item ensure that all activities are a subclass of AppCompatActivity
\end{itemize}

%%%%%%%%%%%%%%%%%%%%%%% SQLite Database %%%%%%%%%%%%%%%%%%%%%%%%%%
\section{SQLite Database}
\subsection{Defining a Schema}
\begin{lstlisting}
public class CrimeDbSchema {

	public static final class CrimeTable {
		public static final String NAME = "crimes";

		public static final class Cols {
			public static final String UUID = "uuid";
			public static final String TITLE = "title";
			public static final String DATA = "date";
			public static final String SOLVED = "solved";
		}
	}
}
\end{lstlisting}

\subsection{Building the Initial Database}
Always need to follow a few basic steps:
\begin{itemize}
	\item Check to see whether the database already exists.
	\item If it does not, create it and create the tables and initial data it needs.
	\item If id does, open it and see what version of the schema it has.
	\item If it is an old version, upgrade it to a newer version.
\end{itemize}
SQLiteOpenHelper can be used to handle all of this.

\subsection{Opening an SQLiteDatabase}
By extending SQLiteOpenHelper, we give control over to it to do the heavy lifting in opening the database.
\begin{lstlisting}
public class CrimeBaseHelper extends SQLiteOpenHelper {

	private static final int VERSION = 1;
	private static final String DATABASE_NAME = "crimeBase.db";

	public CrimeBaseHelper(@Nullable Context context) {
		super(context, DATABASE_NAME, null, VERSION);
	}

	@Override
	public void onCreate(SQLiteDatabase sqLiteDatabase) {

	}

	@Override
	public void onUpgrade(SQLiteDatabase sqLiteDatabase, int i, int i1) {

	}
}
\end{lstlisting}
To access the database we can then call getWritableDatabase()
\begin{lstlisting}
private CrimeLab(Context context) {
	this.mContext = context.getApplicationContext();
	this.mDatabase = new CrimeBaseHelper(mContext).getWritableDatabase();
}
\end{lstlisting}
When we do this, SQLiteOpenHelper will:
\begin{itemize}
	\item open up /data/data/com....../databases/thedatabasebeingopened.db
	\subitem it will create a new database file if it does not already exist.
	
	\item If it is the first time the database has been created, call onCreate(...), then save out the latest version number.
	
	\item If it is not the first time, check the version number.
	\subitem If the version number in CrimeBaseHelper is higher, call onUpgrade(....) 
\end{itemize}

\subsection{Writing to the Database}
\subsubsection{ContentValues}
Writes and updates are done with ContentVales - a key-value store class, like Java's HashMap or Bundles.
\\
Example of a helper function to create the instance of ContentValues for a row:
\begin{lstlisting}
private static ContentValues getContentValues(@NonNull Crime crime) {
	ContentValues values = new ContentValues();
	values.put(CrimeTable.Cols.UUID, crime.getId().toString());
	values.put(CrimeTable.Cols.TITLE, crime.getTitle());
	values.put(CrimeTable.Cols.DATE, crime.getDate().getTime());
	values.put(CrimeTable.Cols.SOLVED, crime.isSolved() ? 1 : 0);

	return values;
}
\end{lstlisting}

\subsubsection{Inserting rows}
Can insert a new row to the database by using the content values object, and using the insert(...,...,...) method on the SQLite database object.

\begin{lstlisting}
public void addCrime(Crime crime) {
	ContentValues values = getContentValues(crime);
	mDatabase.insert(CrimeTable.NAME, null, values);
}
\end{lstlisting}

\subsubsection{Updating Rows}

\begin{lstlisting}
public void updateCrime(Crime crime) {
	String uuidString = crime.getId().toString();
	ContentValues values = getContentValues(crime);
	mDatabase.update(CrimeTable.NAME, values,
		CrimeTable.Cols.UUID + " = ?",
		new String[] { uuidString });
}
\end{lstlisting}
To update a row, the same content values object is used from inserting; however, the update(...,...,...,...) method is called in the database object.
\\
The third parameter is the where clause string which specifies what rows are updated.  In this case, the UUID is used to identify the row.
\\
To do this, the '?' syntax is used which tells the database to treat whatever string is in the following parameter as a pure string - not as SQL code.  This prevents an SQL injection attack.

\subsection{Reading from the Database}
 Reading from the database is done by using the query(...) function. 
 \\
 This returns a 'Cursor' object.
 \\
 A cursor stores the retrieved data in key value pairs.
 \subsubsection{Retrieving a Cursor }
 \begin{lstlisting}
public Cursor queryCrimes(String whereClause, String[] whereArgs) {
	Cursor cursor  = mDatabase.query(
		CrimeTable.NAME,
		null,  // selects all columns
		whereClause,
		whereArgs,
		null, // groupBy
		null,  // having
		null  // orderBy
	);
	return cursor;
}
 \end{lstlisting}
 \subsubsection{Using a Cursor}
 To actually retrieve the returned data/values, the get[Type]([Int]) function is used, where the Int is the key with the value of the column index, and the Type is the type of value which is stored.
 \\
 To get the column index from the column name/title, the getColumnIndex([String]) can be used.
 \begin{lstlisting}
String title = getString(getColumnIndex(CrimeTable.Cols.TITLE));
long date = getLong(getColumnIndex(CrimeTable.Cols.DATE));
int isSolved = getInt(getColumnIndex(CrimeTable.Cols.SOLVED));
 \end{lstlisting} 
 It is cleaning, however, to use a custom wrapper of a cursor to encapsulate the cursor and retrieving of data withing one object.
 \\
 Therefore create a class which extends Cursor
 \begin{lstlisting}
public class CrimeCursorWrapper extends CursorWrapper {

	public CrimeCursorWrapper(Cursor cursor) {
		super(cursor);
	}

	public Crime getCrime() {
		String uuidString = this.getString(this.getColumnIndex(CrimeTable.Cols.UUID));
		String title = getString(getColumnIndex(CrimeTable.Cols.TITLE));
		long date = getLong(getColumnIndex(CrimeTable.Cols.DATE));
		int isSolved = getInt(getColumnIndex(CrimeTable.Cols.SOLVED));

		Crime crime = new Crime(UUID.fromString(uuidString));
		crime.setTitle(title);
		crime.setDate(new Date(date));
		crime.setSolved(isSolved != 0);

		return crime;
	}
}
 \end{lstlisting}
From this point, convert the retrieved data into model objects.
\\
To move the cursor along from one part of the query to the next, use the Cursor.moveToFirst() to move to the beginning of the query and Cursor.moveToNext() to move to the next position.
\\
To check is the cursor is still inside the data set, using Cursor.isAfterLast()
\\
Hence the name, cursor.
\begin{lstlisting}
public List<Crime> getCrimes() {
	List<Crime> crimes = new ArrayList<>();
	CrimeCursorWrapper cursorWrapper = queryCrimes(null, null);

	try {
		cursorWrapper.moveToFirst();
		while (!cursorWrapper.isAfterLast()) {
			crimes.add(cursorWrapper.getCrime());
			cursorWrapper.moveToNext();
		}
	} finally {
		cursorWrapper.close();
	}
	
	return crimes;
}
\end{lstlisting}
Remember to close the cursor.
\\
If you don't the app will run out of open file handlers and the app will crash.
\\
Example of retrieving specific row:
\begin{lstlisting}
public Crime getCrime(UUID id) {
	CrimeCursorWrapper cursor = queryCrimes(
		CrimeTable.Cols.UUID + "",
		new String[] { id.toString() }
	);

	try {
		if (cursor.getCount() == 0) {
		return null;
	}

	cursor.moveToFirst();
	return cursor.getCrime();
	} finally {
		cursor.close();
	}
}
\end{lstlisting}

\subsection{Deleting Rows}
\begin{lstlisting}
mDatabase.delete(CrimeTable.NAME, 
					CrimeTable.Cols.UUID + " = ?",
					new String[] { crime.getId().toString() });
\end{lstlisting}

%%%%%%%%%%%%%%%%%%% Implicit Intents  %%%%%%%%%%%%%%%%%%%
\section{Implicit Intents}
Implicit intents are used to start activities in another app.
\\
In an implicit intent, you describe the job you require to be completed, and the OS will open an appropriate activity.
\\
Compared to Explicit intents where you specify the class of the activity to start.
\subsection{The Parts of an Implicit Intent}
\begin{itemize}
	\item action
	\subitem Typically constants from the Intent class.
	\subitem 
	
	\item location of any data
	\item type of data that the action is for
	\item optional categories
\end{itemize}

%%%%%%%%%%%%%%%%%%% Strings %%%%%%%%%%%%%%%%%%%
\section{Strings}
\subsection{Plurals}
\begin{lstlisting}
<plurals name="subtitle_plural">
	<item quantity="one">%1$d crime</item>
	<item quantity="other">%1$d crimes</item>
</plurals>
\end{lstlisting}
To retrieve/use the string:
\begin{lstlisting}
getResources().getQuantityString(R.plurals.subtitle_plural, crimeSize, crimeSize);
\end{lstlisting}

%%%%%%%%%%%%%% Refactoring Techniques and Tools %%%%%%%%%%%%%%%%
\section{Refactoring Techniques and Tools}
There are many techniques and tools that can be used to make refactoring code easier.
\subsection{Extracting a method with Android Studio}
\begin{enumerate}
	\item  Highlight the code that you want to be extracted
	\item Right-click and select Refactor $\rightarrow$ Extract $\rightarrow$ Method
	\item Set the Visibility and method Name 
	\item Press Refactor or Preview to preview the changes
	\item If there are multiple occurrences of the highlighted text being extracted, android studio will ask if you want to replace these as well 
	\subitem You can either replace each occurrence one by one, or by choosing all.
\end{enumerate}

\end{document}
